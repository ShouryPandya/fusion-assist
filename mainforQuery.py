from fastapi import FastAPI, HTTPException, Request, Response #
from fastapi.middleware.cors import CORSMiddleware #
from pydantic import BaseModel #
from agents.base_agent import SCMAgent, HCMAgent #
import logging #
import json #
import base64 #
import requests #
from datetime import datetime #
from typing import Optional #
from config import Config #

# Import Oracle DB utilities
import oracle_db_utils #
import oracledb # Import for error handling #

# Configure logging with file output for debugging
logging.basicConfig( #
    level=logging.INFO, #
    filename="chatbot.log", #
    filemode="a", #
    format="%(asctime)s:%(levelname)s:%(name)s:%(message)s" #
)
logger = logging.getLogger("query_api") #
console_handler = logging.StreamHandler() #
console_handler.setLevel(logging.INFO) #
logger.addHandler(console_handler) #

app = FastAPI(title="Fusion Query Agent API") #

# CORS middleware configuration
app.add_middleware( #
    CORSMiddleware, #
    allow_origins=[ #
        "https://fa-elzx-dev10-saasfaprod1.fa.ocs.oraclecloud.com", #
        "https://fa-erzv-dev39-saasfademo1.ds-fa.oraclepdemos.com", #
        "http://localhost:3000", #
        "http://localhost:8080", #
        "http://127.0.0.1:3000" #
    ],
    allow_credentials=True, #
    allow_methods=["GET", "POST", "OPTIONS"], #
    allow_headers=["Content-Type", "Authorization", "Accept"], #
    expose_headers=["*"], #
    max_age=600 #
)

logger.info("Initializing SCMAgent") #
scm_agent = SCMAgent() #
logger.info("Initializing HCMAgent") #
hcm_agent = HCMAgent() #

def initialize_query_contexts_db(): #
    db_path = "query_contexts.db" # This is no longer used but keeping it for context of original file #
    logger.info("Starting database initialization for Oracle query_contexts table") #
    
    conn = None #
    try:
        conn = oracle_db_utils.get_oracle_connection() #
        cursor = conn.cursor() #
        
        logger.info("Creating QUERY_CONTEXTS table if not exists (Oracle)") #
        try:
            cursor.execute("""
                CREATE TABLE QUERY_CONTEXTS (
                    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                    AGENT_TYPE VARCHAR2(50) NOT NULL,
                    CONTEXT VARCHAR2(4000) NOT NULL,
                    QUERY CLOB NOT NULL
                )
            """) #
            logger.info("QUERY_CONTEXTS table created (Oracle).") #
        except oracledb.Error as e:
            error_obj, = e.args #
            if error_obj.code == 955: # ORA-00955: name is already used by an existing object #
                 logger.warning(f"Table QUERY_CONTEXTS already exists. Skipping creation. Error: {error_obj.message}") #
            else:
                raise # Re-raise other errors #


        logger.info("Checking if QUERY_CONTEXTS table is empty (Oracle)") #
        cursor.execute("SELECT COUNT(*) FROM QUERY_CONTEXTS") #
        count = cursor.fetchone()[0] #
        logger.debug(f"Found {count} rows in QUERY_CONTEXTS table (Oracle)") #
        
        if count == 0: #
            logger.info("Table is empty, inserting initial queries into Oracle DB") #
            
            # SCM Inventory Query
            scm_inventory_query = """
            SELECT
                esi.item_number                        AS "Item Number",
                iop.organization_code                  AS "Organization Code",
                ioqd.transaction_quantity              AS "Quantity Onhand",
                ioqd.transaction_uom_code              AS "Primary UOM",
                ioqd.secondary_transaction_quantity    AS "Secondary Quantity Onhand",
                ioqd.secondary_uom_code                AS "Secondary UOM",
                esi.description                        AS "Item Description",
                ioqd.subinventory_code                 AS "Subinventory Code",
                iil.segment1 || '.' || iil.segment2 || '.' || iil.segment3 AS Locator
            FROM
                egp_system_items esi,
                inv_onhand_quantities_detail ioqd,
                inv_org_parameters iop,
                inv_item_locations iil
            WHERE
                esi.inventory_item_id = ioqd.inventory_item_id
                AND esi.organization_id = ioqd.organization_id
                AND esi.organization_id = iop.organization_id
                AND ioqd.locator_id = iil.inventory_location_id(+)
                AND ioqd.organization_id = iil.organization_id(+)
                AND ioqd.subinventory_code = iil.subinventory_code(+)
            """ #
            cursor.execute( #
                "INSERT INTO QUERY_CONTEXTS (AGENT_TYPE, CONTEXT, QUERY) VALUES (:agent_type, :context, :query)", #
                agent_type="scm", #
                context="Keywords: inventory, stock, quantity, item, subinventory, locator. Description: Retrieves item numbers, quantities on hand, and locations from inventory tables.", #
                query=scm_inventory_query #
            )
            
            # SCM Purchase Order Query
            scm_po_query = """
            WITH asn_data AS
            (
                SELECT
                    rsl.po_line_location_id
                    , rsh.shipment_header_id
                    , rsh.shipment_num                                                                                                   asn
                    , to_date(to_char(CAST(rsh.shipped_date AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY')                asn_date
                    , nvl(rsl.quantity_shipped, 0)                                                                                       qty_inbound
                FROM
                    rcv_shipment_lines   rsl
                    , rcv_shipment_headers rsh
                WHERE
                    rsl.shipment_header_id = rsh.shipment_header_id
                    AND rsh.asn_type       = 'ASN'
                    AND NOT EXISTS
                    (
                        SELECT
                            1
                        FROM
                            rcv_transactions rt
                        WHERE
                            rt.shipment_line_id     = rsl.shipment_line_id
                            AND rt.transaction_type = 'DELIVER'
                    )
            )
            , po_co_data AS
            (
                SELECT
                    pver1.po_header_id
                    , (
                        SELECT
                            pu.username
                        FROM
                            per_users pu
                        WHERE
                            pver1.originator_id = pu.person_id
                    ) order_last_changed_by
                    , to_date(to_char(CAST(pver1.submitted_date AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY') date_changed
                FROM
                    po_versions pver1
                WHERE
                    pver1.change_order_status = 'PROCESSED'
                    AND (pver1.co_canceled_flag IS NULL OR pver1.co_canceled_flag = 'N')
                    AND pver1.co_num IS NOT NULL
                    AND pver1.co_num = (
                        SELECT MAX(pver.co_num)
                        FROM po_versions pver
                        WHERE
                            pver.po_header_id = pver1.po_header_id
                            AND pver.change_order_status = 'PROCESSED'
                            AND (pver.co_canceled_flag IS NULL OR pver.co_canceled_flag = 'N')
                            AND pver.co_num IS NOT NULL
                    )
            )
            SELECT
                po_data.*
                , CASE
                    WHEN matching_basis = 'QUANTITY' THEN nvl(local_cur_unit_price * qty_open, 0)
                    ELSE nvl(local_cur_unit_price, 0)
                END local_curr_amt_open
                , CASE
                    WHEN (lead_time IS NULL OR cur_promised_date IS NULL) THEN 'No Lead Time'
                    WHEN (to_date(to_char(CAST(sysdate AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY') > (cur_promised_date - lead_time))
                    AND asn IS NULL
                    AND matching_basis = 'QUANTITY'
                    THEN (to_date(to_char(CAST(sysdate AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY') - (cur_promised_date - lead_time)) || ' Days Late'
                    ELSE NULL
                END bol_status
            FROM
            (
                SELECT
                    po_detail.*
                    , nvl(qty_ordered - qty_received, 0) qty_open
                    , nvl((po_exchange_rate * po_unit_price), 0) local_cur_unit_price
                    , nvl(qty_inbound * po_unit_price, 0) po_inbound_amt
                    , CASE
                        WHEN (cur_promised_date IS NULL OR prev_promised_date IS NULL) THEN NULL
                        ELSE cur_promised_date - prev_promised_date
                    END no_of_days_diff
                FROM
                (
                    SELECT
                        psv.segment1 vendor_number
                        , psv.vendor_name
                        , to_date(to_char(CAST(pha.creation_date AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY') po_date
                        , pha.segment1 po_num
                        , pla.line_num po_line_num
                        , iodv.organization_code receiving_warehouse
                        , pltv.line_type po_line_type
                        , ecv.category_code product_class
                        , ecv.category_name product_class_desc
                        , nvl(esiv.item_number, REPLACE(REPLACE(pla.item_description, CHR(13), ' '), CHR(10), ' ')) item_code_or_desc
                        , esiv.item_number ItemNumber
                        , esiv.INVENTORY_ITEM_ID
                        , plla.shipment_num po_schedule_no
                        , pda.distribution_num po_dist_no
                        , nvl(pha.rate, 1) po_exchange_rate
                        , prha.requisition_number
                        , pha.currency_code po_curr
                        , fnd_flex_ext.get_segs('GL', 'GL#', gcc.chart_of_accounts_id, gcc.code_combination_id) po_charge_acct
                        , CASE
                            WHEN (SELECT COUNT(plla1.line_location_id) FROM po_line_locations_all plla1
                                WHERE plla1.line_location_id = plla.line_location_id
                                AND plla1.promised_date IS NULL AND plla1.need_by_date IS NULL) = 1 THEN NULL
                            ELSE nvl(plla.promised_date, plla.need_by_date)
                        END cur_promised_date
                        , pu.username po_requisition_creator
                        , flv.meaning po_line_location_status
                        , pla.matching_basis
                        , CASE
                            WHEN pla.matching_basis = 'QUANTITY' THEN nvl(pda.quantity_ordered, 0)
                            ELSE 0
                        END qty_ordered
                        , CASE
                            WHEN pla.matching_basis = 'QUANTITY' THEN nvl(pda.quantity_delivered, 0)
                            ELSE 0
                        END qty_received
                        , CASE
                            WHEN pla.matching_basis = 'QUANTITY' THEN nvl(pla.unit_price, 0)
                            ELSE nvl(pda.amount_ordered, 0)
                        END po_unit_price
                        , ad.asn
                        , ad.asn_date
                        , nvl(ad.qty_inbound, 0) qty_inbound
                        , CASE
                            WHEN (cur_promised_date IS NULL OR prev_promised_date IS NULL) THEN NULL
                            WHEN (nvl(plla.promised_date, plla.need_by_date) - to_date(to_char(CAST(sysdate AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY')) >= 0
                            THEN 'Due In ' || (nvl(plla.promised_date, plla.need_by_date) - to_date(to_char(CAST(sysdate AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY')) || ' Days'
                            ELSE abs(nvl(plla.promised_date, plla.need_by_date) - to_date(to_char(CAST(sysdate AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY')) || ' Days Late'
                        END order_status
                        , CASE
                            WHEN (SELECT COUNT(plla1.line_location_id) FROM po_line_locations_all plla1
                                WHERE plla1.line_location_id = plla.line_location_id
                                AND plla1.promised_date IS NULL AND plla1.need_by_date IS NULL) = 1 THEN NULL
                            WHEN (SELECT COUNT(pllaa.line_location_id) FROM po_line_locations_archive_all pllaa
                                WHERE pllaa.line_location_id = plla.line_location_id) = 0
                            THEN (SELECT nvl(pllda.promised_date, pllda.need_by_date)
                                FROM po_line_locations_draft_all pllda
                                WHERE pllda.line_location_id = plla.line_location_id)
                            WHEN (SELECT COUNT(pllaa.line_location_id) FROM po_line_locations_archive_all pllaa
                                WHERE pllaa.line_location_id = plla.line_location_id) = 1
                            THEN (SELECT nvl(pllaa.promised_date, pllaa.need_by_date)
                                FROM po_line_locations_archive_all pllaa
                                WHERE pllaa.line_location_id = plla.line_location_id)
                            ELSE (
                                SELECT a.prev_promised_date
                                FROM (
                                    SELECT
                                        nvl(pllaa.promised_date, pllaa.need_by_date) prev_promised_date
                                        , RANK() OVER(ORDER BY to_date(to_char(CAST(pllaa.last_update_date AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY HH24:MI:SS'), 'DD/MM/YYYY HH24:MI:SS') DESC) rnk
                                    FROM po_line_locations_archive_all pllaa
                                    WHERE pllaa.line_location_id = plla.line_location_id
                                ) a
                                WHERE a.rnk = 2
                            )
                        END prev_promised_date
                        , pcd.order_last_changed_by
                        , pcd.date_changed
                        , pssv.attribute_number1 lead_time
                        , CASE WHEN ad.asn IS NOT NULL THEN 'Yes' ELSE 'No' END asn_only
                        , (SELECT hrl.country FROM inv_organization_definitions_v iodv1, hr_locations_all hrl
                            WHERE iodv1.organization_id = plla.ship_to_organization_id AND iodv1.location_id = hrl.location_id) io_country
                        , pssv.country sup_site_country
                        , CASE
                            WHEN (SELECT hrl.country FROM inv_organization_definitions_v iodv1, hr_locations_all hrl
                                WHERE iodv1.organization_id = plla.ship_to_organization_id AND iodv1.location_id = hrl.location_id) = pssv.country THEN 'No'
                            ELSE 'Yes'
                        END overseas_supply
                    FROM
                        po_headers_all pha
                        , poz_suppliers_v psv
                        , po_lines_all pla
                        , po_line_locations_all plla
                        , fnd_lookup_values flv
                        , inv_organization_definitions_v iodv
                        , po_line_types_vl pltv
                        , egp_system_items_vl esiv
                        , egp_categories_vl ecv
                        , po_distributions_all pda
                        , por_req_distributions_all prda
                        , por_requisition_lines_all prla
                        , por_requisition_headers_all prha
                        , gl_code_combinations gcc
                        , per_users pu
                        , asn_data ad
                        , po_co_data pcd
                        , poz_supplier_sites_v pssv
                    WHERE
                        pha.type_lookup_code = 'STANDARD'
                        AND pha.vendor_id = psv.vendor_id
                        AND pha.po_header_id = pla.po_header_id
                        AND pla.po_line_id = plla.po_line_id
                        AND plla.schedule_status = flv.lookup_code
                        AND flv.lookup_type = 'ORDER_SCHEDULE_STATUS'
                        AND flv.meaning = 'Open'
                        AND flv.enabled_flag = 'Y'
                        AND flv.language = userenv('LANG')
                        AND nvl(trunc(flv.end_date_active), trunc(to_date(to_char(CAST(sysdate AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY'))) >= trunc(to_date(to_char(CAST(sysdate AS TIMESTAMP) AT TIME ZONE 'UTC', 'DD/MM/YYYY'), 'DD/MM/YYYY'))
                        AND plla.ship_to_organization_id = iodv.organization_id
                        AND pla.line_type_id = pltv.line_type_id
                        AND pla.item_id = esiv.inventory_item_id (+)
                        AND plla.ship_to_organization_id = esiv.organization_id (+)
                        AND pla.category_id = ecv.category_id (+)
                        AND plla.line_location_id = pda.line_location_id
                        AND pda.req_distribution_id = prda.distribution_id (+)
                        AND prda.requisition_line_id = prla.requisition_line_id (+)
                        AND prla.requisition_header_id = prha.requisition_header_id (+)
                        AND pda.code_combination_id = gcc.code_combination_id
                        AND pda.deliver_to_person_id = pu.person_id (+)
                        AND plla.line_location_id = ad.po_line_location_id (+)
                        AND pha.po_header_id = pcd.po_header_id (+)
                        AND pha.vendor_site_id = pssv.vendor_site_id
                ) po_detail
            ) po_data
            WHERE
                asn_only = nvl(:p_asn_only, asn_only)
                AND overseas_supply = nvl(:p_overseas_supply, overseas_supply)
            ORDER BY
                po_date desc,
                po_num,
                po_line_num,
                po_schedule_no,
                po_dist_no
            """ #
            cursor.execute( #
                "INSERT INTO QUERY_CONTEXTS (AGENT_TYPE, CONTEXT, QUERY) VALUES (:agent_type, :context, :query)", #
                agent_type="scm", #
                context="Keywords: purchase order, PO, supplier, order number, status, asn. Description: Fetches purchase order details including order numbers, suppliers, statuses, and ASN information.", #
                query=scm_po_query #
            )
            
            # HCM Employee Query
            hcm_employee_query = """
            SELECT papf.person_id,
                papf.person_number AS employee_number,
                ppnf.display_name AS employee_name,
                paam.assignment_number,
                paam.assignment_status_type AS assignment_status,
                haou.name AS organization_name,
                hp.name AS position_name,
                hl.location_code AS location_name,
                ppnf.full_name AS manager_name,
                pg.name AS grade_name,
                pp.date_of_birth,
                ppos.date_start AS hire_date,
                pcf.contract_end_date,
                pea.email_address AS primary_email
            FROM per_all_people_f papf
            JOIN per_all_assignments_m paam ON papf.person_id = paam.person_id
            JOIN hr_all_organization_units haou ON paam.organization_id = haou.organization_id
            JOIN hr_all_positions hp ON paam.position_id = hp.position_id
            JOIN hr_locations_all hl ON paam.location_id = hl.location_id
            LEFT JOIN per_assignment_supervisors_f pasf ON paam.assignment_id = pasf.assignment_id
            LEFT JOIN per_person_names_f ppnf ON pasf.manager_id = ppnf.person_id
            LEFT JOIN per_grades pg ON paam.grade_id = pg.grade_id
            LEFT JOIN per_periods_of_service ppos ON paam.period_of_service_id = ppos.period_of_service_id
            LEFT JOIN per_persons pp ON papf.person_id = pp.person_id
            LEFT JOIN per_contracts_f pcf ON paam.contract_id = pcf.contract_id
            LEFT JOIN per_email_addresses pea ON papf.person_id = pea.person_id AND pea.email_type = 'W1'
            WHERE TRUNC(SYSDATE) BETWEEN papf.effective_start_date AND papf.effective_end_date
                AND TRUNC(SYSDATE) BETWEEN paam.effective_start_date AND paam.effective_end_date
                AND paam.primary_flag = 'Y'
            ORDER BY papf.person_number
            """ #
            cursor.execute( #
                "INSERT INTO QUERY_CONTEXTS (AGENT_TYPE, CONTEXT, QUERY) VALUES (:agent_type, :context, :query)", #
                agent_type="hcm", #
                context="Keywords: employee, person, name, hire date, organization, assignment, count, total, number. Description: Retrieves employee details like person ID, name, hire date, and assignment information, or aggregates like total employee count.", #
                query=hcm_employee_query #
            )
            
            conn.commit() #
            logger.info("Initialized QUERY_CONTEXTS database with initial queries (Oracle).") #
        
    except oracledb.Error as e: #
        error_obj, = e.args #
        if error_obj.code not in [942, 955]: # Log other errors #
            logger.error(f"Error during Oracle database initialization for QUERY_CONTEXTS: {error_obj.message}", exc_info=True) #
            raise #
    except ConnectionError as e: #
        logger.error(f"Failed to get Oracle DB connection during QUERY_CONTEXTS initialization: {str(e)}", exc_info=True) #
        raise #
    finally:
        if conn: #
            oracle_db_utils.release_oracle_connection(conn) #
            logger.debug("Released connection after QUERY_CONTEXTS DB initialization.") #


def initialize_conversation_history_table():
    """Initializes the CHATBOT_CONVERSATION_HISTORY table in Oracle if it doesn't exist."""
    logger.info("Starting database initialization for Oracle CHATBOT_CONVERSATION_HISTORY table") #
    conn = None
    try:
        conn = oracle_db_utils.get_oracle_connection() #
        cursor = conn.cursor() #
        
        logger.info("Creating CHATBOT_CONVERSATION_HISTORY table if not exists (Oracle)")
        try:
            cursor.execute("""
                CREATE TABLE CHATBOT_CONVERSATION_HISTORY (
                    MESSAGE_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                    THREAD_ID VARCHAR2(255) NOT NULL,
                    MESSAGE_TIMESTAMP TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
                    SENDER_ROLE VARCHAR2(10) NOT NULL CHECK (SENDER_ROLE IN ('USER', 'AI')),
                    MESSAGE_CONTENT CLOB,
                    AGENT_STREAM VARCHAR2(10) NOT NULL 
                )
            """)
            logger.info("CHATBOT_CONVERSATION_HISTORY table created (Oracle).")
            # Add indexes for performance
            cursor.execute("CREATE INDEX idx_conv_hist_thread_stream_ts ON CHATBOT_CONVERSATION_HISTORY (THREAD_ID, AGENT_STREAM, MESSAGE_TIMESTAMP DESC)")
            logger.info("Indexes created for CHATBOT_CONVERSATION_HISTORY table.")
            conn.commit() #

        except oracledb.Error as e:
            error_obj, = e.args #
            if error_obj.code == 955: # ORA-00955: name is already used by an existing object #
                 logger.warning(f"Table CHATBOT_CONVERSATION_HISTORY or its index already exists. Skipping creation. Error: {error_obj.message}")
            else:
                logger.error(f"Error creating CHATBOT_CONVERSATION_HISTORY table: {error_obj.message}", exc_info=True) #
                raise #
        
    except oracledb.Error as e: #
        error_obj, = e.args #
        logger.error(f"Oracle DB error during CHATBOT_CONVERSATION_HISTORY initialization: {error_obj.message}", exc_info=True) #
        raise #
    except ConnectionError as e: #
        logger.error(f"Failed to get Oracle DB connection during CHATBOT_CONVERSATION_HISTORY initialization: {str(e)}", exc_info=True) #
        raise #
    finally:
        if conn: #
            oracle_db_utils.release_oracle_connection(conn) #
            logger.debug("Released connection after CHATBOT_CONVERSATION_HISTORY DB initialization.")

def initialize_attachments_table():
    """Initializes the CHATBOT_ATTACHMENTS table in Oracle if it doesn't exist."""
    logger.info("Starting database initialization for Oracle CHATBOT_ATTACHMENTS table")
    conn = None
    try:
        conn = oracle_db_utils.get_oracle_connection()
        cursor = conn.cursor()
        
        logger.info("Creating CHATBOT_ATTACHMENTS table if not exists (Oracle)")
        try:
            cursor.execute("""
                CREATE TABLE CHATBOT_ATTACHMENTS (
                    ATTACHMENT_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
                    MESSAGE_ID NUMBER NOT NULL,
                    FILENAME VARCHAR2(255) NOT NULL,
                    MIMETYPE VARCHAR2(100) NOT NULL,
                    FILE_CONTENT BLOB NOT NULL,
                    CREATED_TIMESTAMP TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    CONSTRAINT fk_message
                        FOREIGN KEY (MESSAGE_ID)
                        REFERENCES CHATBOT_CONVERSATION_HISTORY(MESSAGE_ID)
                        ON DELETE CASCADE
                )
            """)
            logger.info("CHATBOT_ATTACHMENTS table created (Oracle).")
            conn.commit()

        except oracledb.Error as e:
            error_obj, = e.args
            if error_obj.code == 955: # ORA-00955: name is already used by an existing object
                logger.warning(f"Table CHATBOT_ATTACHMENTS already exists. Skipping creation. Error: {error_obj.message}")
            else:
                logger.error(f"Error creating CHATBOT_ATTACHMENTS table: {error_obj.message}", exc_info=True)
                raise
        
    except oracledb.Error as e:
        error_obj, = e.args
        logger.error(f"Oracle DB error during CHATBOT_ATTACHMENTS initialization: {error_obj.message}", exc_info=True)
        raise
    except ConnectionError as e:
        logger.error(f"Failed to get Oracle DB connection during CHATBOT_ATTACHMENTS initialization: {str(e)}", exc_info=True)
        raise
    finally:
        if conn:
            oracle_db_utils.release_oracle_connection(conn)
            logger.debug("Released connection after CHATBOT_ATTACHMENTS DB initialization.")


# Initialize databases on startup
try:
    logger.info("Starting database initialization (Oracle QUERY_CONTEXTS)") #
    initialize_query_contexts_db() #
    logger.info("Starting database initialization (Oracle CHATBOT_CONVERSATION_HISTORY)") #
    initialize_conversation_history_table() #
    logger.info("Starting database initialization (Oracle CHATBOT_ATTACHMENTS)")
    initialize_attachments_table()
except Exception as e:
    logger.error(f"Failed to initialize Oracle databases: {str(e)}") #
    raise #

@app.on_event("shutdown") #
async def shutdown_event(): #
    logger.info("Shutting down application, closing Oracle connection pool.") #
    oracle_db_utils.close_oracle_connection_pool() #

class QueryRequest(BaseModel): #
    question: str #
    thread_id: Optional[str] = None #
    format_preference: Optional[str] = "natural_language" #
    agent_type: str # # Renamed to agent_stream in DB, but request can keep agent_type

async def process_query(request: Request, agent_instance_placeholder): # agent_instance_placeholder not used directly due to logic change
    logger.info("Received question") #
    body = await request.body() #
    logger.debug(f"Raw request body: {body}") #
    question = None #
    thread_id = None #
    format_preference = "natural_language" #
    agent_type_from_request = None # Use a different variable name to avoid confusion #
    try:
        try: #
            json_body = json.loads(body) #
            logger.debug(f"Parsed JSON body: {json_body}") #
            if "question" in json_body: #
                question = json_body["question"] #
                thread_id = json_body.get("thread_id") #
                format_preference = json_body.get("format_preference", "natural_language") #
                agent_type_from_request = json_body.get("agent_type") #
            else: #
                pass #
        except json.JSONDecodeError: #
            logger.debug("Failed to parse body as JSON, attempting to read form data.") #
            pass #
        
        if not question: #
            form_data = await request.form() #
            logger.debug(f"Form data: {form_data}") #
            if "question" in form_data: #
                question = form_data["question"] #
                thread_id = form_data.get("thread_id") #
                format_preference = form_data.get("format_preference", "natural_language") #
                agent_type_from_request = form_data.get("agent_type") #
            else: #
                raise HTTPException(status_code=422, detail="Missing 'question' field in JSON or form data") #
        
        if not agent_type_from_request: #
            raise HTTPException(status_code=422, detail="Missing 'agent_type' field") #
        
        # agent_stream will be used for DB interaction; agent_type_from_request is what client sends
        agent_stream = agent_type_from_request.lower().replace("_agent", "") #
        if agent_stream not in ["scm", "hcm"]: #
            raise HTTPException(status_code=422, detail="Invalid 'agent_type'. Must be 'scm' or 'hcm'") #
        
        if format_preference not in ["natural_language", "table"]: #
            format_preference = "natural_language" #

        logger.info(f"Received query request for agent_stream: {agent_stream}, question: {question}, thread_id: {thread_id}, format_preference: {format_preference}") #
        
        selected_agent = None
        if agent_stream == "scm":
            selected_agent = scm_agent
        elif agent_stream == "hcm":
            selected_agent = hcm_agent
        
        if not selected_agent: #
             raise HTTPException(status_code=500, detail="Internal error: Agent not found")

        logger.info(f"Invoking {selected_agent.__class__.__name__} to process question") #
        result = selected_agent.run(question, thread_id, format_preference, agent_stream) # Pass agent_stream
        
        if result.get("error"): #
            logger.error(f"Agent returned an error: {result['error']}") #
            return { #
                "status": "error", #
                "message": result["error"], #
                "response": result["response"], #
                "thread_id": result["thread_id"], #
                "question_type": result.get("question_type", "unknown"), #
                "format_preference": format_preference #
            }
        logger.info(f"Query processed successfully, response: {result['response'][:100]}...") #
        logger.debug(f"Full agent result: {result}") #
        return { #
            "status": "success", #
            "response": result["response"], #
            "thread_id": result["thread_id"], #
            "question_type": result.get("question_type", "unknown"), #
            "format_preference": format_preference #
        }
    except HTTPException as http_exc: #
        raise http_exc #
    except Exception as e: #
        logger.error(f"Error processing request: {str(e)}", exc_info=True) #
        error_message = str(e) #
        if isinstance(e, oracledb.Error): #
            error_obj, = e.args #
            error_message = f"Database error: {error_obj.message} (Code: {error_obj.code})" #
        elif isinstance(e, ConnectionError): #
            error_message = f"Database connection error: {str(e)}" #
        raise HTTPException(status_code=500, detail=f"An internal server error occurred: {error_message}") #

@app.post("/scm/query") #
async def scm_query(request: Request): #
    logger.info("Processing SCM query request") #
    return await process_query(request, None) # Pass None, agent determined in process_query #

@app.post("/hcm/query") #
async def hcm_query(request: Request): #
    logger.info("Processing HCM query request") #
    return await process_query(request, None) # Pass None, agent determined in process_query #

@app.get("/health") #
async def health_check(): #
    logger.info("Health check requested") #
    try: #
        conn = oracle_db_utils.get_oracle_connection() #
        cursor = conn.cursor() #
        cursor.execute("SELECT 1 FROM DUAL") #
        cursor.fetchone() #
        oracle_db_utils.release_oracle_connection(conn) #
        return {"status": "healthy", "database_status": "connected"} #
    except Exception as e: #
        logger.error(f"Health check failed due to database connection issue: {str(e)}") #
        return {"status": "unhealthy", "database_status": f"disconnected: {str(e)}"} #

@app.get("/download/attachment/{attachment_id}")
async def download_document(attachment_id: int):
    """Downloads a document directly from the CHATBOT_ATTACHMENTS table."""
    conn = None
    try:
        logger.info(f"Downloading attachment with ID: {attachment_id}")
        conn = oracle_db_utils.get_oracle_connection()
        cursor = conn.cursor()
        
        # Query to fetch the file content (BLOB), filename, and mimetype
        sql = "SELECT FILENAME, MIMETYPE, FILE_CONTENT FROM CHATBOT_ATTACHMENTS WHERE ATTACHMENT_ID = :id"
        cursor.execute(sql, id=attachment_id)
        result = cursor.fetchone()
        
        if not result:
            logger.error(f"Attachment with ID {attachment_id} not found in the database.")
            raise HTTPException(status_code=404, detail="Attachment not found")
        
        filename, mimetype, file_content_blob = result
        
        # Read the content from the LOB object
        file_bytes = file_content_blob.read()
        
        logger.info(f"Attachment {attachment_id} ({filename}) retrieved successfully from database.")
        
        return Response(
            content=file_bytes,
            media_type=mimetype,
            headers={"Content-Disposition": f'attachment; filename="{filename}"'}
        )
    except oracledb.Error as e:
        error_obj, = e.args
        logger.error(f"Database error downloading attachment {attachment_id}: {error_obj.message}", exc_info=True)
        raise HTTPException(status_code=500, detail="Error retrieving file from database")
    except Exception as e:
        logger.error(f"Error processing attachment download for ID {attachment_id}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Internal server error during file download: {str(e)}")
    finally:
        if conn:
            oracle_db_utils.release_oracle_connection(conn)


if __name__ == "__main__": #
    import uvicorn #
    logger.info("Starting FastAPI server") #
    uvicorn.run(app, host="10.1.0.124", port=8080) #